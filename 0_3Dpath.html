<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Drone Obstacle Course Challenge</title>
<style>
body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: left;
    padding: 10px;
    margin: 0;
    background-color: #f0f0f0;
}
#game-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: left;
    gap: 5px;
    margin-bottom: 5px;
}
#obstacle-course {
    width: 600px;
    height: 400px;
    border: 2px solid #000;
    background-color: #fff;
    position: relative;
}
#code-area {
    width: 300px;
    border: 2px solid #000;
    padding: 10px;
    background-color: #fff;
}
#command-buttons {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 5px;
}
.button-row {
    display: flex;
    gap: 5px;
}
button {
    padding: 5px 10px;
    cursor: pointer;
    color: white;
    border: none;
    border-radius: 3px;
}
.green-button {
    background-color: #4CAF50;
}
.orange-button {
    background-color: #FFA500;
}
#run-button, #home-button, #level-select {
    margin-top: 10px;
    padding: 10px 20px;
    font-size: 16px;
}
#run-button {
    background-color: #FF0000;
}
#home-button {
    background-color: #FFC0CB;
}
#level-select {
    background-color: #0000FF;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}
#code-input {
    width: 100%;
    height: 150px;
    resize: vertical;
}
#message {
    margin-top: 5px;
    font-weight: bold;
    text-align: left;
    min-height: 10px;
}
#view-controls {
    margin-top: 10px;
    display: flex;
    gap: 10px;
}
#instructions {
    margin-bottom: 20px;
    text-align: left;
    font-size: 18px;
    line-height: 1.5;
}
#view-controls button {
    color: #8B4513;
    font-weight: bold;
    border: 2px solid #8B4513;
    background-color: white;
}
@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0; }
    100% { opacity: 1; }
}
.blink {
    animation: blink 1s infinite;
}
@keyframes colorChange {
    0% { color: red; }
    33% { color: green; }
    66% { color: blue; }
    100% { color: red; }
}
.color-change {
    animation: colorChange 3s infinite;
}
/* Additional styles for Level Select */
#level-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
}
#counters {
    margin-top: 10px;
    display: flex;
    gap: 20px;
}
#counters span {
    font-weight: bold;
}
</style>
</head>
<body>
<h2>3D Drone Obstacle Course Challenge</h2>
<div id="game-container">
    <div id="obstacle-course"></div>
    <div id="code-area">
        <div id="command-buttons">
            <div class="button-row">
                <button class="green-button" onclick="addCommandAtCursor('throttleUp')">Throttle Up</button>
                <button class="green-button" onclick="addCommandAtCursor('throttleDown')">Throttle Down</button>
            </div>
            <div class="button-row">
                <button class="green-button" onclick="addCommandAtCursor('yawLeft90deg')">Yaw Left 90°</button>
                <button class="green-button" onclick="addCommandAtCursor('yawRight90deg')">Yaw Right 90°</button>
            </div>
            <div class="button-row">
                <button class="orange-button" onclick="addCommandAtCursor('pitchForward')">Pitch Forward</button>
                <button class="orange-button" onclick="addCommandAtCursor('pitchBackward')">Pitch Backward</button>
            </div>
            <div class="button-row">
                <button class="orange-button" onclick="addCommandAtCursor('rollLeft')">Roll Left</button>
                <button class="orange-button" onclick="addCommandAtCursor('rollRight')">Roll Right</button>
            </div>
        </div>
        <textarea id="code-input"></textarea>
        <br>
        <div class="button-row">
            <button id="run-button" onclick="runCode()">Run Code</button>
            <button id="home-button" onclick="homePosition()">Home</button>
            <select id="level-select" onchange="changeLevel()">
                <option value="1" selected>Level 1</option>
                <option value="2">Level 2</option>
                <option value="3">Level 3</option>
            </select>
        </div>
        <div id="counters">
            <span>No. of Attempts: <span id="attempts-count">0</span></span>
            <span>No. of Steps: <span id="steps-count">0</span></span>
        </div>
    </div>
</div>
<div id="message"></div>
<div id="view-controls">
    <button onclick="rotateView('right')">Rotate Left</button>
    <button onclick="rotateView('left')">Rotate Right</button>
    <button onclick="moveViewUp()">Up</button>
    <button onclick="moveViewDown()">Down</button>
    <button onclick="zoom('in')">Zoom In</button>
    <button onclick="zoom('out')">Zoom Out</button>
</div>

<!-- Audio Elements -->
<script>
    // Preload audio files
    const hoopSound = new Audio('bonus.mp3'); // Ensure this file is in the same directory
    const goalSound = new Audio('sweet.mp3'); // Ensure this file is in the same directory
    const warn1Sound = new Audio('warn1.mp3'); // Warning for out-of-order hoop passing
    const warn2Sound = new Audio('warn2.mp3'); // Warning for reaching goal prematurely
    const startSound = new Audio('start.mp3'); // Sound to play on load and level change

    // Optionally, you can set the volume
    hoopSound.volume = 0.5;
    goalSound.volume = 0.5;
    warn1Sound.volume = 0.5;
    warn2Sound.volume = 0.5;
    startSound.volume = 0.5; // Set desired volume for start sound

    // **Change for Request 3:** Unlock audio on first user interaction to ensure sounds play on iPad
    function unlockAudio() {
        // Play a silent sound to unlock the audio context
        const silentSound = new Audio();
        silentSound.volume = 0;
        silentSound.play().then(() => {
            silentSound.pause();
        }).catch((error) => {
            console.warn('Audio unlock failed:', error);
        });

        // Remove the event listeners after unlocking
        document.body.removeEventListener('click', unlockAudio);
        document.body.removeEventListener('touchstart', unlockAudio);
    }

    // Add event listeners to unlock audio on user interaction
    document.body.addEventListener('click', unlockAudio, { once: true });
    document.body.addEventListener('touchstart', unlockAudio, { once: true });

    // **New Addition:** Array to track cloned sounds
    const clonedSounds = [];

    // **New Addition:** Helper function to play sounds with cloning
    function playSound(audio, track=true) {
        const clone = audio.cloneNode();
        clone.play().catch((error) => {
            console.warn('Sound playback was prevented:', error);
        });
        if (track) {
            clonedSounds.push(clone);
            clone.addEventListener('ended', () => {
                const index = clonedSounds.indexOf(clone);
                if (index > -1) {
                    clonedSounds.splice(index, 1);
                }
            });
        }
    }
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Initialize variables
let scene, camera, renderer, drone, obstacles = [], axesHelper;
let goalMarker;
const codeInput = document.getElementById('code-input');
const messageDiv = document.getElementById('message');

let dronePosition = new THREE.Vector3(0, 0, 0);
let droneRotation = new THREE.Euler(0, 0, 0, 'XYZ'); // Upright
let goalPosition = new THREE.Vector3(0, 0, 0); // Will be set in generateGoalPosition()
let currentHoop = 1;

// Yaw Tracking Variable
let targetYaw = 0;

// Global variables to manage timeouts and intervals
let commandTimeouts = [];
let blinkIntervals = {};

// Counters for Attempts and Steps
let attemptsCount = 0;
let stepsCount = 0;
const attemptsDisplay = document.getElementById('attempts-count');
const stepsDisplay = document.getElementById('steps-count');

// Current Level
let currentLevel = 1;

// Alert flag to ensure alert message is shown only once per out-of-order pass
let alertShown = false;

// Level configurations - Revised as per requirements
const levelConfigs = {
    1: { vertical: 1, horizontal: 0 }, // Level 1: one vertical hoop
    2: { vertical: 1, horizontal: 1 }, // Level 2: one vertical and one horizontal hoop
    3: { vertical: 2, horizontal: 1 }  // Level 3: two vertical and one horizontal hoop
    // Levels 4 and 5 are deleted
};

// Constants for minimum distances
const MIN_DISTANCE_FROM_HOOPS = 4; // Minimum distance between hoops
const MIN_DISTANCE_FROM_START = 5; // Minimum distance from start
const MIN_DISTANCE_TO_GOAL_FOR_HOOP = 5; // Minimum distance from any hoop when placing goal

// Blinking variables
let frontCircles = [];
let rearCircles = [];
let lastBlinkTime = 0;
const blinkDuration = 500; // milliseconds
let blinkState = true;

// Command Queue
let commandQueue = [];
let isExecuting = false;

// Throttle Animation Variables
let isThrottling = false;

// Yaw Animation Variables
let isYawing = false;
const yawDuration = 500; // milliseconds per 90 degrees

function initGame() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(600, 400);
    document.getElementById('obstacle-course').innerHTML = '';
    document.getElementById('obstacle-course').appendChild(renderer.domElement);

    // **Change for Request 2:** Set default camera position to a two-stepped zoomed-in view
    camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 1000);
    camera.position.set(10, 7, 10); // Adjusted for closer view
    camera.lookAt(dronePosition);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);

    createDrone();
    createHulaHoops(currentLevel);
    createCoordinatePlane();
    addDirectionIndicators();
    addWatermark();
    addWatermarkSTEM(); 
    addVerticalLines();

    axesHelper = new THREE.AxesHelper(10);
    scene.add(axesHelper);

    // Start blinking the first hoop
    if (obstacles.length > 0) {
        blinkHoop(obstacles[0]);
    }

    animate();

    // **Change for Sound on Init:** Play startSound when the game initializes
    playSound(startSound, false); // Do not track startSound clones

    // Add event listener to update steps when code changes
    codeInput.addEventListener('input', updateStepsCount);
}

function createDrone() {
    const droneGroup = new THREE.Group();

    // 1. Create a blue, semi-transparent cube with adjusted dimensions
    const cubeWidth = 1.5; // Increased to 1.5 from 1
    const cubeHeight = 0.5; // Assuming y-axis is height and remains the same
    const cubeDepth = 1.5; // Reduced to half from 3
    const cubeGeometry = new THREE.BoxGeometry(cubeWidth, cubeHeight, cubeDepth);
    const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    droneGroup.add(cube);

    // 2. Create four circles with swapped colors
    const circleRadius = 0.225; // Enlarged by 1.5x from 0.15
    const circleHeight = cubeHeight / 2 + 0.01; // slightly above the cube

    const frontCircleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 1 }); // Swapped to green
    const rearCircleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1 }); // Swapped to red

    const circleGeometry = new THREE.CylinderGeometry(circleRadius, circleRadius, 0.02, 32);

    // Front Left Circle
    const frontLeft = new THREE.Mesh(circleGeometry, frontCircleMaterial.clone());
    frontLeft.position.set(-cubeWidth / 2, circleHeight, cubeDepth / 2);
    droneGroup.add(frontLeft);

    // Front Right Circle
    const frontRight = new THREE.Mesh(circleGeometry, frontCircleMaterial.clone());
    frontRight.position.set(cubeWidth / 2, circleHeight, cubeDepth / 2);
    droneGroup.add(frontRight);

    // Rear Left Circle
    const rearLeft = new THREE.Mesh(circleGeometry, rearCircleMaterial.clone());
    rearLeft.position.set(-cubeWidth / 2, circleHeight, -cubeDepth / 2);
    droneGroup.add(rearLeft);

    // Rear Right Circle
    const rearRight = new THREE.Mesh(circleGeometry, rearCircleMaterial.clone());
    rearRight.position.set(cubeWidth / 2, circleHeight, -cubeDepth / 2);
    droneGroup.add(rearRight);

    // Store references for blinking
    frontCircles = [frontLeft, frontRight];
    rearCircles = [rearLeft, rearRight];

    // 3. Add a triangle pointing to the rear
    const triangleGeometry = new THREE.ConeGeometry(1, 2, 3);
    const triangleMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
    const triangle = new THREE.Mesh(triangleGeometry, triangleMaterial);
    triangle.rotation.x = -Math.PI / 2; // Pointing backward
    triangle.position.set(0, circleHeight + 0, -cubeDepth / 2 - 0); // Positioned at the rear
    droneGroup.add(triangle);

    // 4. Integrate the Start Marker (Green Spot with 'S' Label) into the Drone
    const startGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const startMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const startMarker = new THREE.Mesh(startGeometry, startMaterial);
    startMarker.position.set(0, circleHeight + 0.25, 0); // Positioned at the top center of the drone
    droneGroup.add(startMarker);

    addLabel(startMarker, 'S', 0, 0.8, 0, 'green'); // Bold "S" inside the start marker
    addShadow(startMarker);

    droneGroup.rotation.x = 0; // Ensure upright position

    scene.add(droneGroup);
    drone = droneGroup;
}

function createHulaHoops(level) {
    obstacles = []; // Clear existing obstacles

    for (let i = 1; i <= levelConfigs[level].vertical; i++) {
        const position = generateNonOverlappingPosition();
        const radius = getRandomRadius(2, 3);
        createHulaHoop(position.x, position.y, position.z, radius, i, 'vertical');
    }
    for (let i = 1; i <= levelConfigs[level].horizontal; i++) {
        const position = generateNonOverlappingPosition();
        const radius = getRandomRadius(1.5, 2.5);
        createHulaHoop(position.x, position.y, position.z, radius, levelConfigs[level].vertical + i, 'horizontal');
    }
    createGoalMarker(); // Generate goal after hoops are placed
}

function createHulaHoop(x, y, z, radius, number, orientation) {
    const hoopGroup = new THREE.Group();
    const hoopGeometry = new THREE.TorusGeometry(radius, 0.1, 16, 100);
    const hoopMaterial = new THREE.MeshPhongMaterial({ color: 0xff8c00, transparent: true, opacity: 0.7 });
    const hoop = new THREE.Mesh(hoopGeometry, hoopMaterial);

    // Set orientation based on level
    if (orientation === 'vertical') {
        hoop.rotation.x = Math.PI / 2;
    } else if (orientation === 'horizontal') {
        hoop.rotation.x = 0;
    }

    hoopGroup.add(hoop);
    hoopGroup.position.set(x, y, z);
    scene.add(hoopGroup);
    obstacles.push(hoopGroup);

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 128;
    canvas.height = 128;
    context.fillStyle = 'white';
    context.fillRect(0, 0, 128, 128);
    context.fillStyle = 'black';
    context.font = 'Bold 64px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(number.toString(), 64, 64);

    const numberTexture = new THREE.CanvasTexture(canvas);
    const numberMaterial = new THREE.SpriteMaterial({ map: numberTexture });
    const numberSprite = new THREE.Sprite(numberMaterial);
    numberSprite.scale.set(1, 1, 1);
    numberSprite.position.set(0, radius + 0.5, 0);
    hoopGroup.add(numberSprite);
}

function generateNonOverlappingPosition() {
    const maxAttempts = 100;
    let attempt = 0;
    let position;

    while (attempt < maxAttempts) {
        const x = THREE.MathUtils.randFloatSpread(14); // Increased spread to -7 to 7 for better spacing
        const y = THREE.MathUtils.randFloat(2, 5); // 2 to 5 to avoid ground level
        const z = THREE.MathUtils.randFloatSpread(14); // -7 to 7

        position = new THREE.Vector3(x, y, z);

        // Ensure the hoop is within boundaries (-10 to 10 on X and Z)
        if (Math.abs(x) > 10 || Math.abs(z) > 10) continue;

        // Check for overlap with existing hoops
        let overlapping = false;
        for (let hoop of obstacles) {
            if (position.distanceTo(hoop.position) < MIN_DISTANCE_FROM_HOOPS) {
                overlapping = true;
                break;
            }
        }

        // Check for minimum distance from start
        if (position.distanceTo(new THREE.Vector3(0, 0, 0)) < MIN_DISTANCE_FROM_START) {
            overlapping = true;
        }

        // Check for minimum distance from goal (if goal is already placed)
        if (goalMarker && position.distanceTo(goalMarker.position) < MIN_DISTANCE_TO_GOAL_FOR_HOOP) {
            overlapping = true;
        }

        if (!overlapping) {
            return position;
        }

        attempt++;
    }

    // Fallback position if no non-overlapping position is found
    return new THREE.Vector3(0, 2, 0);
}

function getRandomRadius(min, max) {
    return THREE.MathUtils.randFloat(min, max);
}

function createCoordinatePlane() {
    const size = 20;
    const divisions = 20;
    const gridHelper = new THREE.GridHelper(size, divisions, 0xcccccc, 0xcccccc);
    scene.add(gridHelper);

    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

        for (let i = -10; i <= 10; i += 2) {
            if (i !== 0) {
                createText(font, textMaterial, i.toString(), i, 0, -10);
                createText(font, textMaterial, i.toString(), -10, 0, i);
            }
        }

        createText(font, textMaterial, 'X', 11, 0, 0);
        createText(font, textMaterial, 'Z', 0, 0, 11);
        createText(font, textMaterial, 'Y', 0, 11, 0);
    });
}

function createText(font, material, text, x, y, z) {
    const textGeometry = new THREE.TextGeometry(text, {
        font: font,
        size: 0.5,
        height: 0.1,
    });
    const textMesh = new THREE.Mesh(textGeometry, material);
    textMesh.position.set(x, y, z);
    scene.add(textMesh);
}

function addDirectionIndicators() {
    addDirectionIndicator(new THREE.Vector3(12, 0, 0), 'Right', 0xff0000);
    addDirectionIndicator(new THREE.Vector3(-12, 0, 0), 'Left', 0xff0000);
    addDirectionIndicator(new THREE.Vector3(0, 12, 0), 'Up', 0x00ff00);
    addDirectionIndicator(new THREE.Vector3(0, -12, 0), 'Down', 0x00ff00);
    addDirectionIndicator(new THREE.Vector3(0, 0, 12), 'Rear', 0x0000ff);
    addDirectionIndicator(new THREE.Vector3(0, 0, -12), 'Front', 0x0000ff);
}

function addDirectionIndicator(position, text, color) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    context.fillStyle = `rgb(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255})`;
    context.font = 'Bold 40px Arial';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, 128, 128);

    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.copy(position);
    sprite.scale.set(2, 2, 2);
    scene.add(sprite);
}

function createStartAndGoalMarkers() {
    // Goal Marker
    createGoalMarker();
}

function createGoalMarker() {
    // Remove existing goalMarker if it exists
    if (goalMarker) {
        scene.remove(goalMarker);
        goalMarker = null;
    }

    // Generate a non-overlapping position for the goal based on the current level
    let position = generateGoalPosition(currentLevel);
    goalPosition.copy(position); // Update the goalPosition vector

    const goalGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const goalMaterial = new THREE.MeshPhongMaterial({ color: 0xff8c00, transparent: true, opacity: 0.5 });
    goalMarker = new THREE.Mesh(goalGeometry, goalMaterial);
    goalMarker.position.copy(position);
    scene.add(goalMarker);

    // Place the "G" label inside the goal marker
    addLabel(goalMarker, 'G', 0, 0.8, 0.5, 'orange'); // Bold "G" inside the goal marker

    addShadow(goalMarker);
}

function addShadow(object) {
    const shadowGeometry = new THREE.CircleGeometry(0.5, 32);
    const shadowMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
    const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.01;
    object.add(shadow);
}

function addLabel(object, text, x, y, z, color) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 256;
    context.fillStyle = 'transparent';
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = color;
    context.font = `Bold 200px Arial`;
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(text, 128, 128);

    const texture = new THREE.CanvasTexture(canvas);
    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.position.set(x, y, z);
    sprite.scale.set(1, 1, 1);
    object.add(sprite);
}

function addWatermark() {
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xd3d3d3 }); // Light grey color
        const watermarkGeometry = new THREE.TextGeometry('EdUHK', {
            font: font,
            size: 1,
            height: 0.05,
        });
        const watermarkMesh = new THREE.Mesh(watermarkGeometry, textMaterial);
        watermarkMesh.rotation.x = -Math.PI / 2;
        watermarkMesh.position.set(5, 0.1, 0); // Position along positive X-axis at ground level
        scene.add(watermarkMesh);
    });
}

// Added function to include "STEM Education" watermark
function addWatermarkSTEM() {
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xd3d3d3 }); // Light grey color
        const stemTextGeometry = new THREE.TextGeometry('STEM Education', {
            font: font,
            size: 0.7,
            height: 0.05,
        });
        const stemWatermarkMesh = new THREE.Mesh(stemTextGeometry, textMaterial);
        stemWatermarkMesh.rotation.y = Math.PI / 2;
        stemWatermarkMesh.position.set(0, 0.1, 10); // Position along positive Z-axis at ground level
        scene.add(stemWatermarkMesh);
    });
}

function addVerticalLines() {
    const material = new THREE.LineBasicMaterial({ color: 0xcccccc });
    for (let y = 2; y <= 10; y += 2) { // Start from y=2 to match hoop elevation
        const points = [];
        points.push(new THREE.Vector3(-10, y, -10));
        points.push(new THREE.Vector3(10, y, -10));
        points.push(new THREE.Vector3(10, y, 10));
        points.push(new THREE.Vector3(-10, y, 10));
        points.push(new THREE.Vector3(-10, y, -10));

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);
    }
}

function animate() {
    requestAnimationFrame(animate);

    // Blinking logic
    const now = Date.now();
    if (now - lastBlinkTime > blinkDuration) {
        blinkState = !blinkState;
        lastBlinkTime = now;

        frontCircles.forEach(circle => {
            circle.material.opacity = blinkState ? 1 : 0;
        });

        rearCircles.forEach(circle => {
            circle.material.opacity = blinkState ? 1 : 0;
        });
    }

    renderer.render(scene, camera);
}

// **Change for Request 1:** Modify addCommand to insert at cursor position
function addCommandAtCursor(command) {
    const start = codeInput.selectionStart;
    const end = codeInput.selectionEnd;
    const before = codeInput.value.substring(0, start);
    const after  = codeInput.value.substring(end, codeInput.value.length);
    codeInput.value = before + command + '\n' + after;
    // Move the cursor to after the inserted command
    const newCursorPosition = start + command.length + 1; // +1 for the newline
    codeInput.selectionStart = codeInput.selectionEnd = newCursorPosition;
    codeInput.focus();
    updateStepsCount();
}

async function runCode() {
    if (isExecuting) return; // Prevent multiple executions at the same time
    isExecuting = true;

    // **Revision 2:** Disable the "Run Code" button after it's pressed
    document.getElementById('run-button').disabled = true;

    // **Remove Sound Play from Run Code:** 
    // Removed startSound.play() from here as per user requirement

    // Clear previous timeouts
    commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    commandTimeouts = [];

    // Parse commands
    const commands = codeInput.value.trim().split('\n').filter(cmd => cmd.trim() !== '');

    // Enqueue all commands
    for (const command of commands) {
        await executeSingleCommand(command.trim());
    }

    checkGoal();
    isExecuting = false;
    // Note: The "Run Code" button remains disabled until "Home" or "Level" is pressed
}

async function executeSingleCommand(command) {
    return new Promise((resolve) => {
        switch (command) {
            case 'pitchForward':
                moveDrone(0, 0, -1); // Move forward along z-axis
                setTimeout(() => {
                    resolve();
                }, 200); // Wait for movement to complete
                break;
            case 'pitchBackward':
                moveDrone(0, 0, 1); // Move backward along z-axis
                setTimeout(() => {
                    resolve();
                }, 200); // Wait for movement to complete
                break;
            case 'rollLeft':
                moveDrone(-1, 0, 0); // Move left along x-axis
                setTimeout(() => {
                    resolve();
                }, 200); // Wait for movement to complete
                break;
            case 'rollRight':
                moveDrone(1, 0, 0); // Move right along x-axis
                setTimeout(() => {
                    resolve();
                }, 200); // Wait for movement to complete
                break;
            case 'throttleUp':
                throttleDrone('up').then(() => {
                    resolve();
                });
                break;
            case 'throttleDown':
                throttleDrone('down').then(() => {
                    resolve();
                });
                break;
            case 'yawLeft90deg':
                yawDrone('left', Math.PI / 2).then(() => {
                    resolve();
                });
                break;
            case 'yawRight90deg':
                yawDrone('right', Math.PI / 2).then(() => {
                    resolve();
                });
                break;
            default:
                console.warn(`Unknown command: ${command}`);
                resolve();
        }
    });
}

function throttleDrone(direction) {
    return new Promise((resolve) => {
        if (isThrottling) {
            // If already throttling, ignore new throttle commands
            resolve();
            return;
        }
        isThrottling = true;
        const steps = 10;
        const stepDuration = 50; // milliseconds
        let currentStep = 0;
        const deltaY = direction === 'up' ? 0.1 : -0.1;

        const throttleInterval = setInterval(() => {
            if (currentStep < steps) {
                moveDrone(0, deltaY, 0);
                currentStep++;
            } else {
                clearInterval(throttleInterval);
                isThrottling = false;
                resolve();
            }
        }, stepDuration);
    });
}

function yawDrone(direction, angle) {
    return new Promise((resolve) => {
        if (isYawing) {
            // If already yawing, ignore new yaw commands
            resolve();
            return;
        }
        isYawing = true;
        const steps = 10;
        const stepDuration = yawDuration / steps;
        let currentStep = 0;
        const deltaAngle = direction === 'left' ? angle / steps : -angle / steps;

        const yawInterval = setInterval(() => {
            if (currentStep < steps) {
                drone.rotation.y += deltaAngle;
                currentStep++;
            } else {
                clearInterval(yawInterval);
                isYawing = false;
                resolve();
            }
        }, stepDuration);
    });
}

function moveDrone(x, y, z) {
    const movement = new THREE.Vector3(x, y, z);
    movement.applyEuler(drone.rotation);
    dronePosition.add(movement);
    drone.position.copy(dronePosition);
    checkHulaHoops();
}

function checkHulaHoops() {
    obstacles.forEach((hoop, index) => {
        const distance = dronePosition.distanceTo(hoop.position);
        const requiredDistance = (hoop.children[0].geometry.parameters.radius + 0.5); // Extra buffer

        if (distance < requiredDistance) {
            if (index + 1 === currentHoop) {
                hoop.children[0].material.color.setHex(0x00ff00); // Change color to green
                hoop.children[0].material.opacity = 0.7; // Ensure no blinking

                // Stop blinking
                if (blinkIntervals[index]) {
                    clearInterval(blinkIntervals[index]);
                    delete blinkIntervals[index];
                }

                messageDiv.textContent = `Congratulations! You've passed through hoop ${currentHoop}!`;
                messageDiv.classList.add('blink');
                // **Change for Multiple Plays:** Use playSound to allow multiple plays
                playSound(hoopSound);
                setTimeout(() => {
                    messageDiv.classList.remove('blink');
                }, 3000);
                currentHoop++;
                alertShown = false; // Reset alert flag for next hoop
                if (currentHoop <= obstacles.length) {
                    obstacles[currentHoop - 1].children[0].material.transparent = true;
                    obstacles[currentHoop - 1].children[0].material.opacity = 0.7;
                    blinkHoop(obstacles[currentHoop -1]);
                }
            } else {
                // **Revision 1:** Ensure alert is shown only when n > currentHoop
                const hoopNumber = index + 1;
                if (hoopNumber > currentHoop && !alertShown) {
                    alert(`Please pass through hoop ${currentHoop} first!`);
                    playSound(warn1Sound);
                    alertShown = true;
                }
                // If not the correct hoop, do not turn it green and allow the user to continue
            }
        }
    });
}

function blinkHoop(hoop) {
    const hoopId = obstacles.indexOf(hoop);
    if (blinkIntervals[hoopId]) return; // Prevent multiple intervals on the same hoop
    blinkIntervals[hoopId] = setInterval(() => {
        if (hoop.children[0].material.opacity === 0.7) {
            hoop.children[0].material.opacity = 0.3;
        } else {
            hoop.children[0].material.opacity = 0.7;
        }
    }, 500);
}

function checkGoal() {
    if (dronePosition.distanceTo(goalPosition) < 1.5) { // Adjusted distance threshold
        if (currentHoop <= obstacles.length) {
            alert(`You've reached the goal without passing all hoops! Please complete all hoops first.`);
            playSound(warn2Sound);
        } else {
            messageDiv.textContent = "🎉 Congratulations! You've successfully navigated all hoops and reached the goal! 🎉";
            
            messageDiv.classList.add('blink', 'color-change');
            goalMarker.material.color.setHex(0x00ff00);
            // **Change for Multiple Plays:** Use playSound to allow multiple plays
            playSound(goalSound);
            blinkGoal();
            setTimeout(() => {
                messageDiv.classList.remove('blink', 'color-change');
            }, 5000);
        }
    } else {
        messageDiv.textContent = "🛸 Aim for the goal! Navigate carefully through all the hoops.";
    }
}

function blinkGoal() {
    let blinkCount = 0;
    const maxBlinks = 10;
    const originalColor = goalMarker.material.color.getHex();
    
    const blinkInterval = setInterval(() => {
        goalMarker.material.color.setHex(goalMarker.material.color.getHex() === 0x00ff00 ? 0xff0000 : 0x00ff00);
        blinkCount++;
        if (blinkCount >= maxBlinks) {
            clearInterval(blinkInterval);
            goalMarker.material.color.setHex(originalColor);
        }
    }, 300);
}

function homePosition() {
    // Stop all scheduled commands
    commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    commandTimeouts = [];

    // Stop all blinking intervals
    Object.values(blinkIntervals).forEach(intervalId => clearInterval(intervalId));
    blinkIntervals = {};

    // Reset command queue and execution flag
    commandQueue = [];
    isExecuting = false;

    // **Revision 2:** Re-enable the "Run Code" button when "Home" is pressed
    document.getElementById('run-button').disabled = false;

    // Reset drone position and rotation
    dronePosition.set(0, 0, 0);
    drone.rotation.set(0, 0, 0, 'XYZ');
    drone.position.copy(dronePosition);
    drone.quaternion.setFromEuler(drone.rotation);
    camera.position.set(10, 7, 10); // Reset to the default zoomed-in position
    camera.lookAt(drone.position);
    messageDiv.textContent = '';
    messageDiv.classList.remove('blink', 'color-change');

    // Restore hula hoop colors and opacities
    obstacles.forEach(hoop => {
        hoop.children[0].material.color.setHex(0xff8c00);
        hoop.children[0].material.opacity = 0.7;
    });
    currentHoop = 1;
    alertShown = false; // Reset alert flag

    // Reset goal color
    if (goalMarker) {
        goalMarker.material.color.setHex(0xff8c00);
    }

    // Increment attempts count
    attemptsCount++;
    attemptsDisplay.textContent = attemptsCount;

    // Do NOT reset Steps count upon pressing "Home" as per instructions
    // Steps count will remain as is

    // **New Addition:** Reset all sound effects except "start.mp3"
    clonedSounds.forEach(clone => {
        clone.pause();
    });
    clonedSounds.length = 0;

    // **Remove Sound Play from Home Position:** 
    // Removed startSound.play() from here as per user requirement

    // Start blinking the first hoop again
    if (obstacles.length > 0) {
        blinkHoop(obstacles[0]);
    }
}

function rotateView(direction) {
    const rotationAngle = direction === 'left' ? Math.PI / 18 : -Math.PI / 18;
    const currentPosition = camera.position.clone().sub(dronePosition);
    currentPosition.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationAngle);
    camera.position.copy(dronePosition).add(currentPosition);
    camera.lookAt(dronePosition);
}

function moveViewUp() {
    camera.position.y += 1;
    camera.lookAt(dronePosition);
}

function moveViewDown() {
    if (camera.position.y > 1) { // Prevent camera from going below ground
        camera.position.y -= 1;
        camera.lookAt(dronePosition);
    }
}

function zoom(direction) {
    const zoomFactor = direction === 'in' ? 0.9 : 1.1;
    const currentPosition = camera.position.clone().sub(dronePosition);
    currentPosition.multiplyScalar(zoomFactor);
    camera.position.copy(dronePosition).add(currentPosition);
    camera.lookAt(dronePosition);
}

function changeLevel() {
    const levelSelect = document.getElementById('level-select');
    const selectedLevel = parseInt(levelSelect.value);
    if (selectedLevel !== currentLevel) {
        currentLevel = selectedLevel;
        // **Revision 2:** Clear the code input when selecting a new level
        codeInput.value = '';
        updateStepsCount(); // Update steps count accordingly
        // Reset the game for the new level
        resetGameForNewLevel();
        // **Revision 1:** Unlock the "Run Code" button when a new level is selected
        document.getElementById('run-button').disabled = false;
        // **Change for Sound on Level Change:** Play startSound when a new level is entered
        playSound(startSound, false); // Do not track startSound clones
    }
}

function resetGameForNewLevel() {
    // Stop all scheduled commands
    commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
    commandTimeouts = [];

    // Stop all blinking intervals
    Object.values(blinkIntervals).forEach(intervalId => clearInterval(intervalId));
    blinkIntervals = {};

    // Remove existing hoops from the scene
    obstacles.forEach(hoop => scene.remove(hoop));
    obstacles = [];
    // Remove goalMarker if exists
    if (goalMarker) {
        scene.remove(goalMarker);
        goalMarker = null;
    }

    // Create new hoops based on the selected level
    createHulaHoops(currentLevel);

    // Generate a new goal position
    createGoalMarker();

    // Reset drone position and rotation
    dronePosition.set(0, 0, 0);
    drone.rotation.set(0, 0, 0, 'XYZ');
    drone.position.copy(dronePosition);
    drone.quaternion.setFromEuler(drone.rotation);
    camera.position.set(10, 7, 10); // Reset to the default zoomed-in position
    camera.lookAt(drone.position);
    messageDiv.textContent = '';
    messageDiv.classList.remove('blink', 'color-change');

    // Restore hula hoop colors and opacities
    obstacles.forEach(hoop => {
        hoop.children[0].material.color.setHex(0xff8c00);
        hoop.children[0].material.opacity = 0.7;
    });
    currentHoop = 1;
    alertShown = false; // Reset alert flag

    // Reset goal color
    if (goalMarker) {
        goalMarker.material.color.setHex(0xff8c00);
    }

    // Reset counters when changing levels
    attemptsCount = 0;
    attemptsDisplay.textContent = attemptsCount;

    stepsCount = 0;
    stepsDisplay.textContent = stepsCount;

    // Do NOT reset code input to preserve user code
    // codeInput.value = ''; // Already handled above

    // Start blinking the first hoop again
    if (obstacles.length > 0) {
        blinkHoop(obstacles[0]);
    }
}

function generateGoalPosition(level) {
    // Define goal positions based on level for consistency
    const predefinedGoals = {
        1: new THREE.Vector3(7, 3, 7),
        2: new THREE.Vector3(-7, 3, 7),
        3: new THREE.Vector3(7, 3, -7)
        // Levels 4 and 5 are deleted
    };

    // If predefined position exists for the level, use it
    if (predefinedGoals[level]) {
        // Ensure it's within boundaries and not overlapping with hoops
        const position = predefinedGoals[level].clone();
        let tooClose = false;
        const minDistanceToHoop = MIN_DISTANCE_TO_GOAL_FOR_HOOP; // Minimum distance from any hoop
        obstacles.forEach(hoop => {
            if (position.distanceTo(hoop.position) < minDistanceToHoop) {
                tooClose = true;
            }
        });
        if (!tooClose) {
            return position;
        }
    }

    // Fallback: Random position if predefined is too close
    const maxAttempts = 100;
    let attempt = 0;
    let position;
    const minDistanceToHoop = MIN_DISTANCE_TO_GOAL_FOR_HOOP; // Minimum distance from any hoop

    while (attempt < maxAttempts) {
        const x = THREE.MathUtils.randFloatSpread(14); // -7 to 7
        const y = THREE.MathUtils.randFloat(2, 5); // 2 to 5 to avoid ground level
        const z = THREE.MathUtils.randFloatSpread(14); // -7 to 7

        position = new THREE.Vector3(x, y, z);

        // Ensure the goal is not too close to any hoops or the start
        let tooClose = false;
        for (let hoop of obstacles) {
            if (position.distanceTo(hoop.position) < minDistanceToHoop) {
                tooClose = true;
                break;
            }
        }

        if (position.distanceTo(new THREE.Vector3(0, 0, 0)) < MIN_DISTANCE_FROM_START) {
            tooClose = true;
        }

        if (!tooClose) {
            return position;
        }

        attempt++;
    }

    // Fallback position if no suitable position is found
    return new THREE.Vector3(0, 3, 9);
}

initGame();

// Function to update "No. of Steps" based on the current code in the textarea
function updateStepsCount() {
    const commands = codeInput.value.trim().split('\n').filter(cmd => cmd.trim() !== '');
    let totalSteps = 0;

    commands.forEach(commandLine => {
        const baseCommand = commandLine.trim();
        if (baseCommand) {
            totalSteps += 1;
        }
    });

    stepsCount = totalSteps;
    stepsDisplay.textContent = stepsCount;
}

// Ensure steps count updates when code is changed manually
codeInput.addEventListener('input', updateStepsCount);
</script>
</body>
</html>
